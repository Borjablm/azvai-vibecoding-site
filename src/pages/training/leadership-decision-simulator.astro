---
import BaseLayout from "../../layouts/BaseLayout.astro";
---

<BaseLayout
  title="Leadership Decision Simulator | AZVAI Training"
  description="Interactive leadership scenario simulator powered by Lumination API."
  current="training"
>
  <a href="/training" class="back-link">&larr; All training tools</a>

  <section class="hero" style="padding-top: 1.5rem;">
    <p class="eyebrow">training experiment</p>
    <h1>Leadership Decision Simulator</h1>
    <p class="lead">
      Practice manager decisions in realistic workplace scenarios. Generate one situation, choose a response, and get an
      AI coaching debrief.
    </p>
  </section>

  <section class="simulator" aria-label="Leadership decision simulator">
    <section class="sim-panel">
      <h2><span class="step-number">0</span> Add Policy Context (Optional)</h2>
      <p class="sim-note">
        Upload a policy file (<code>.txt</code>, <code>.md</code>, <code>.csv</code>, <code>.pdf</code>) or paste key policy/governance rules. Scenarios and debriefs will align to it.
      </p>
      <label for="policy-file">Upload policy file</label>
      <input id="policy-file" name="policyFile" type="file" accept=".txt,.md,.csv,.pdf,text/plain,text/markdown,text/csv,application/pdf" />

      <label for="policy-context">Or paste policy context</label>
      <textarea
        id="policy-context"
        name="policyContext"
        rows="6"
        placeholder="Example: Managers must document corrective feedback within 48 hours and agree measurable milestones within 2 weeks..."
      ></textarea>
      <p class="sim-note" id="policy-meta">No policy context loaded.</p>
    </section>

    <form id="sim-config" class="sim-panel">
      <h2><span class="step-number">1</span> Configure Scenario</h2>

      <label for="role">Manager Role</label>
      <input id="role" name="role" value="Team Lead" required />

      <label for="challenge">Challenge Type</label>
      <select id="challenge" name="challenge" required>
        <option value="performance-feedback">Performance feedback</option>
        <option value="conflict-resolution">Conflict resolution</option>
        <option value="delegation-pressure">Delegation under pressure</option>
        <option value="change-management">Change management</option>
      </select>

      <label for="difficulty">Difficulty</label>
      <select id="difficulty" name="difficulty" required>
        <option value="easy">Easy</option>
        <option value="intermediate" selected>Intermediate</option>
        <option value="advanced">Advanced</option>
      </select>

      <button type="submit" id="generate-btn">Generate Scenario</button>
    </form>

    <section class="sim-panel" id="scenario-panel" hidden>
      <h2><span class="step-number">2</span> Scenario</h2>
      <p id="scenario-text"></p>
      <div id="options-list" class="option-list"></div>
    </section>

    <form id="decision-form" class="sim-panel" hidden>
      <h2><span class="step-number">3</span> Your Decision</h2>
      <label for="selected-option">Selected Option</label>
      <input id="selected-option" name="selectedOption" readonly required />

      <label for="rationale">Your Rationale</label>
      <textarea id="rationale" name="rationale" rows="4" placeholder="Explain why you chose this option..." required></textarea>

      <button type="submit" id="evaluate-btn">Get Coaching Debrief</button>
    </form>

    <section class="sim-panel" id="debrief-panel" hidden>
      <h2><span class="step-number">4</span> Coaching Debrief</h2>
      <div id="debrief-output" class="debrief-output"></div>
      <button type="button" id="restart-btn" style="margin-top: 0.5rem;">Start New Scenario</button>
    </section>
  </section>

  <script>
    const state = {
      config: null,
      scenario: null,
      options: [],
    };

    const configForm = document.getElementById("sim-config");
    const decisionForm = document.getElementById("decision-form");
    const scenarioPanel = document.getElementById("scenario-panel");
    const debriefPanel = document.getElementById("debrief-panel");
    const scenarioText = document.getElementById("scenario-text");
    const optionsList = document.getElementById("options-list");
    const selectedOptionInput = document.getElementById("selected-option");
    const debriefOutput = document.getElementById("debrief-output");
    const generateBtn = document.getElementById("generate-btn");
    const evaluateBtn = document.getElementById("evaluate-btn");
    const restartBtn = document.getElementById("restart-btn");
    const policyFile = document.getElementById("policy-file");
    const policyContext = document.getElementById("policy-context");
    const policyMeta = document.getElementById("policy-meta");

    function getPolicyContext() {
      return String(policyContext?.value || "").trim();
    }

    async function extractPdfText(file) {
      const pdfjs = await import("https://cdn.jsdelivr.net/npm/pdfjs-dist@4.8.69/build/pdf.min.mjs");
      pdfjs.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.8.69/build/pdf.worker.min.mjs";

      const buffer = await file.arrayBuffer();
      const pdf = await pdfjs.getDocument({ data: buffer }).promise;
      const chunks = [];

      for (let pageIndex = 1; pageIndex <= Math.min(pdf.numPages, 20); pageIndex += 1) {
        const page = await pdf.getPage(pageIndex);
        const text = await page.getTextContent();
        const line = text.items
          .map((item) => ("str" in item ? item.str : ""))
          .filter(Boolean)
          .join(" ");
        chunks.push(line);

        if (chunks.join("\n").length > 20000) {
          break;
        }
      }

      return chunks.join("\n\n").trim();
    }

    function renderOptions(options) {
      optionsList.innerHTML = "";
      options.forEach((option, index) => {
        const button = document.createElement("button");
        button.type = "button";
        button.className = "option-button";
        button.textContent = `${index + 1}. ${option}`;
        button.addEventListener("click", () => {
          selectedOptionInput.value = option;
          document.querySelectorAll(".option-button").forEach((node) => node.classList.remove("selected"));
          button.classList.add("selected");
          decisionForm.hidden = false;
          decisionForm.scrollIntoView({ behavior: "smooth", block: "start" });
        });
        optionsList.appendChild(button);
      });
    }

    function setBusy(button, busy, text) {
      button.disabled = busy;
      button.textContent = busy ? text : button.dataset.defaultText;
    }

    function escapeHtml(value) {
      return String(value || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    async function parseJsonSafe(response) {
      const raw = await response.text();
      if (!raw) {
        return null;
      }
      try {
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    async function postSimulator(payload) {
      const res = await fetch("/api/training/leadership-decision-simulator", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const data = await parseJsonSafe(res);
      if (!res.ok) {
        const message =
          data?.error ||
          data?.message ||
          `Request failed (${res.status}). Check Netlify env vars and redeploy.`;
        throw new Error(message);
      }

      if (!data || typeof data !== "object") {
        throw new Error("Server returned an invalid response.");
      }

      return data.result;
    }

    generateBtn.dataset.defaultText = generateBtn.textContent;
    evaluateBtn.dataset.defaultText = evaluateBtn.textContent;

    configForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      setBusy(generateBtn, true, "Generating...");
      debriefPanel.hidden = true;

      try {
        const formData = new FormData(configForm);
        state.config = {
          role: String(formData.get("role") || "").trim(),
          challenge: String(formData.get("challenge") || "").trim(),
          difficulty: String(formData.get("difficulty") || "").trim(),
        };

        const result = await postSimulator({
          mode: "generate",
          ...state.config,
          policyContext: getPolicyContext(),
        });

        state.scenario = String(result.scenario || "");
        state.options = Array.isArray(result.options) ? result.options.map((item) => String(item)) : [];

        scenarioText.textContent = state.scenario || "No scenario returned.";
        renderOptions(state.options);
        scenarioPanel.hidden = false;
        decisionForm.hidden = true;
        selectedOptionInput.value = "";
        scenarioPanel.scrollIntoView({ behavior: "smooth", block: "start" });
      } catch (error) {
        const message = error instanceof Error ? error.message : "Failed to generate scenario.";
        scenarioText.textContent = message;
        scenarioPanel.hidden = false;
        optionsList.innerHTML = "";
      } finally {
        setBusy(generateBtn, false);
      }
    });

    decisionForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      setBusy(evaluateBtn, true, "Evaluating...");
      debriefPanel.hidden = true;

      try {
        const formData = new FormData(decisionForm);
        const rationale = String(formData.get("rationale") || "").trim();
        const selectedOption = String(formData.get("selectedOption") || "").trim();

        const result = await postSimulator({
          mode: "evaluate",
          ...state.config,
          scenario: state.scenario,
          options: state.options,
          selectedOption,
          rationale,
          policyContext: getPolicyContext(),
        });

        const score = result.score ?? "N/A";
        debriefOutput.innerHTML = `
          <div class="debrief-score">
            <div class="score-value">${score}</div>
            <div class="score-label">${escapeHtml(result.verdict ?? "")}</div>
          </div>
          <div class="debrief-item"><strong>Blind Spot</strong>${escapeHtml(result.blind_spot ?? "N/A")}</div>
          <div class="debrief-item"><strong>What Worked</strong>${escapeHtml(result.what_worked ?? "N/A")}</div>
          <div class="debrief-item"><strong>What To Improve</strong>${escapeHtml(result.what_to_improve ?? "N/A")}</div>
          <div class="debrief-item"><strong>Next Action</strong>${escapeHtml(result.next_action ?? "N/A")}</div>
        `;
        debriefPanel.hidden = false;
        debriefPanel.scrollIntoView({ behavior: "smooth", block: "start" });
      } catch (error) {
        const message = error instanceof Error ? error.message : "Failed to evaluate.";
        debriefOutput.innerHTML = `<div class="debrief-item"><strong>Error</strong>${escapeHtml(message)}</div>`;
        debriefPanel.hidden = false;
      } finally {
        setBusy(evaluateBtn, false);
      }
    });

    restartBtn?.addEventListener("click", () => {
      scenarioPanel.hidden = true;
      decisionForm.hidden = true;
      debriefPanel.hidden = true;
      selectedOptionInput.value = "";
      optionsList.innerHTML = "";
      debriefOutput.innerHTML = "";
      configForm.scrollIntoView({ behavior: "smooth", block: "start" });
    });

    policyFile?.addEventListener("change", async () => {
      const file = policyFile.files?.[0];
      if (!file) {
        policyMeta.textContent = "No policy context loaded.";
        return;
      }

      try {
        const isPdf = file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf");
        const text = isPdf ? await extractPdfText(file) : await file.text();
        const cleaned = text.trim();
        if (!cleaned) {
          policyMeta.textContent = isPdf
            ? "PDF has no extractable text. If it is scanned, paste policy text manually."
            : "Uploaded file is empty.";
          return;
        }

        policyContext.value = cleaned.slice(0, 12000);
        const charCount = policyContext.value.length;
        policyMeta.textContent = `Loaded "${file.name}" (${charCount} chars).`;
      } catch {
        policyMeta.textContent = "Could not read file. Use .txt/.md/.csv or paste content manually.";
      }
    });

    policyContext?.addEventListener("input", () => {
      const charCount = getPolicyContext().length;
      policyMeta.textContent = charCount > 0 ? `Policy context ready (${charCount} chars).` : "No policy context loaded.";
    });
  </script>
</BaseLayout>
